/**
 * @file crypto.h
 * @author Mathieu
 * @brief File containing all the logic for encryption
 * @version 0.1
 * @date 2023-03-24
 *
 * @copyright Copyright (c) 2023
 *
 */

#ifndef MINESERVER_CRYPTO_H
#define MINESERVER_CRYPTO_H

#include <memory>
#include <openssl/rsa.h>
#include <openssl/evp.h>

/**
 * @brief The crypto namespace
 *
 * The namespace containing all of the
 * crypto-related utilities functions.
 */
namespace crypto
{
    /**
     * @brief Inits Crypto
     *
     * Inits OpenSSL and generates an RSA Keypair
     * to be used in encryption.
     * @return true Init went correctly
     * @return false Something went wrong
     */
    bool init();
    /**
     * @brief Cleanups Crypto
     *
     * Cleanups the bloat that was created
     * when starting OpenSSL, including
     * the RSA keypair
     */
    void cleanup();

    /**
     * @brief Encrypts data using the server's RSA keypair
     *
     * Encrypts @p len of @p data and returns it as
     * a unique pointer to the encrypted data
     * of length @p outLen
     * @param data The data to encrypt
     * @param len The length of the data to encrypt
     * @param outLen A pointer to a variable that will store the encrypted data length
     * @return std::unique_ptr<std::byte[]> the encrypted data
     */
    std::unique_ptr<std::byte[]> rsaEncrypt(const std::byte *data, size_t len, size_t *outLen);
    /**
     * @brief Decrypts data using the server's RSA keypair
     *
     * Decrypts @p len of @p data and returns it as
     * a unique pointer to the decrypted data
     * of length @p outLen
     * The keypair used is generated at startup in crypto::init().
     * @param data The data to decrypt
     * @param len The length of the data to decrypt
     * @param outLen A pointer to a variable that will store the encrypted data length
     * @return std::unique_ptr<std::byte[]> the encrypted data
     */
    std::unique_ptr<std::byte[]> rsaDecrypt(const std::byte *data, size_t len, size_t *outLen);
    /**
     * @brief Get the Public RSA Public Key
     *
     * Formats the public key from the startup keypair
     * into DER format, which is an underlying ASN.1
     * format defined by x.509
     * @return std::unique_ptr<std::byte[]> The public key
     */
    std::unique_ptr<std::byte[]> getPublicRSAKey();

    /**
     * @brief Generates randoms bytes securely
     *
     * Generates @p len bytes in a secure way,
     * which just means we let OpenSSL do
     * the heavy lifting.
     * @param len the size of the bytes to generate
     * @return std::unique_ptr<std::byte[]> A pointer to the generated bytes
     */
    std::unique_ptr<std::byte[]> randomSecure(size_t len);

    /**
     * @brief The Minecraft Hashing class
     *
     * The class that wraps around OpenSSL
     * to generate minecrafty-hashes because
     * they are not bothered to do something
     * standard. In the end it is just SHA-1
     * with fancy things on top of it.
     */
    class MinecraftHash
    {
    private:
        EVP_MD_CTX *ctx;

    public:
        /**
         * @brief Construct a new Minecraft Hash object
         *
         * Creates a new Minecraft Hash object, initailizing
         * everything.
         */
        MinecraftHash();
        /**
         * @brief Destroy the Minecraft Hash object
         *
         * Everything is said above.
         */
        ~MinecraftHash();

        /**
         * @brief Updates the hash
         *
         * Updates the SHA-1 hash with @p s
         * @param s the data to update the buffer with
         */
        void update(const std::string &s);
        /**
         * @brief Finalizes the hash
         *
         * Finalizes the hash, returning it in
         * a Minecraft-friendly format.
         * @return std::string the minecraft hash
         */
        std::string finalize();
    };
};

#endif