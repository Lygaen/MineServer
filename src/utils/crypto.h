/**
 * @file crypto.h
 * @author Lygaen
 * @brief The file containing all the logic for encryption
 * @version 0.1
 * @date 2023-03-24
 *
 * @copyright Copyright (c) 2023
 *
 */

#ifndef MINESERVER_CRYPTO_H
#define MINESERVER_CRYPTO_H

#include <memory>
#include <openssl/rsa.h>
#include <openssl/evp.h>
#include <zlib.h>

/**
 * @brief The crypto namespace
 *
 * The namespace containing all of the
 * crypto-related utilities functions.
 */
namespace crypto
{
    /**
     * @brief The length of the rsa keys
     *
     * The length of the RSA keys that the
     * server should generate at the start
     * to be used for encryption scheme.
     */
    constexpr int RSA_KEY_LENGTH = 1024;

    /**
     * @brief Inits Crypto
     *
     * Inits OpenSSL and generates an RSA Keypair
     * to be used in encryption.
     * @return true Init went correctly
     * @return false Something went wrong
     */
    bool init();
    /**
     * @brief Cleanups Crypto
     *
     * Cleanups the bloat that was created
     * when starting OpenSSL, including
     * the RSA keypair
     */
    void cleanup();

    /**
     * @brief Encrypts data using the server's RSA keypair
     *
     * Encrypts @p len of @p data and returns it as
     * a unique pointer to the encrypted data
     * of length @p outLen
     * The keypair used is generated at startup in crypto::init().
     * It uses RSA PKCS1 padding.
     * @param data The data to encrypt
     * @param len The length of the data to encrypt
     * @param outLen A pointer to a variable that will store the encrypted data length
     * @return std::unique_ptr<std::byte[]> the encrypted data
     */
    std::unique_ptr<std::byte[]> rsaEncrypt(const std::byte *data, size_t len, size_t *outLen);
    /**
     * @brief Decrypts data using the server's RSA keypair
     *
     * Decrypts @p len of @p data and returns it as
     * a unique pointer to the decrypted data
     * of length @p outLen
     * The keypair used is generated at startup in crypto::init().
     * It uses RSA PKCS1 padding.
     * @param data The data to decrypt
     * @param len The length of the data to decrypt
     * @param outLen A pointer to a variable that will store the encrypted data length
     * @return std::unique_ptr<std::byte[]> the encrypted data
     */
    std::unique_ptr<std::byte[]> rsaDecrypt(const std::byte *data, size_t len, size_t *outLen);
    /**
     * @brief Get the Public RSA Public Key
     *
     * Formats the public key from the startup keypair
     * into DER format, which is an underlying ASN.1
     * format defined by x.509
     *
     *@param outLen a pointer to a variable that will hold the length of the key returned
     *@return std::byte * The public key formatted
     */
    std::unique_ptr<std::byte[]> getPublicRSAKey(int *outLen);

    /**
     * @brief Generates randoms bytes securely
     *
     * Generates @p len bytes in a secure way,
     * which just means we let OpenSSL do
     * the heavy lifting.
     * @param len the size of the bytes to generate
     * @return std::unique_ptr<std::byte[]> A pointer to the generated bytes
     */
    std::unique_ptr<std::byte[]> randomSecure(size_t len);

    /**
     * @brief MD5 digests a string
     *
     * Returns an MD5 digest of the @p data
     * given, really used just for UUID
     * creation from Player's usernames
     * @param data the data to digest
     * @return std::string the md5 string in hex
     */
    std::string md5Digest(const std::string &data);

    /**
     * @brief The Minecraft Hashing class
     *
     * The class that wraps around OpenSSL
     * to generate minecrafty-hashes because
     * they are not bothered to do something
     * standard. In the end it is just SHA-1
     * with fancy things on top of it.
     */
    class MinecraftHash
    {
    private:
        EVP_MD_CTX *ctx;

    public:
        /**
         * @brief Construct a new Minecraft Hash object
         *
         * Creates a new Minecraft Hash object, initailizing
         * everything.
         */
        MinecraftHash();
        /**
         * @brief Destroy the Minecraft Hash object
         *
         * Everything is said above.
         */
        ~MinecraftHash();

        /**
         * @brief Updates the hash
         *
         * Updates the SHA-1 hash with @p s
         * @param s the data to update the buffer with
         */
        void update(const std::string &s);
        /**
         * @brief Finalizes the hash
         *
         * Finalizes the hash, returning it in
         * a Minecraft-friendly format.
         * @return std::string the minecraft hash
         */
        std::string finalize();
    };

    /**
     * @brief Possible cipher states
     *
     * Enum containing the possibilities of
     * what could do a cipher, to not have
     * to create 2 separate classes.
     */
    enum CipherState
    {
        /**
         * @brief Decrypt Cipher state
         *
         * Cipher state so that the update method decrypts
         * instead encrypting.
         * Same for finalize.
         */
        DECRYPT,
        /**
         * @brief ENCRYPT Cipher state
         *
         * Cipher state so that the update method encrypts
         * instead decrypting.
         * Same for finalize.
         */
        ENCRYPT
    };

    /**
     * @brief AES/CFB8 128bit cipher class
     *
     * I know, it is a *really* long name
     * for a class, but it clearly explains
     * what it does instead of just "cipher".
     * So shut up and accept my beautiful naming talents.
     *
     * Joking, the name should be changed if someone
     * finds something better. Naming things in
     * programming is too hard.
     */
    class AES128CFB8Cipher
    {
    private:
        EVP_CIPHER_CTX *ctx;
        const CipherState state;

    public:
        /**
         * @brief Construct a new AES/CFB8 128bit cipher object
         *
         * Minecraft doesn't really need both @p key and @p iv
         * params, but who knows ! Maybe this very specific
         * piece of code will help someone later on !
         * @param state The cipher state of the cipher
         * @param key The key to use with AES
         * @param iv The IV to use with AES
         */
        AES128CFB8Cipher(CipherState state, const std::byte *key, const std::byte *iv);
        /**
         * @brief Destroy the AES/CFB8 128bit cipher object
         *
         * Pretty much explicit. Finally we destroy
         * that longe-named class !
         */
        ~AES128CFB8Cipher();

        /**
         * @brief Updates, encrypting or decrypting depending on the state
         *
         * Encrypts or Decrypts the content in @p data of size @p len
         * and stores it in @p out and returns the written size
         * The @p out buffer should be at least of the length
         * calculated by AES128CFB8Cipher::calculateBufferSize()
         * @param data the data to read then encrypt / decrypt
         * @param len the length of the data to read
         * @param out the output buffer
         * @return int the length of the buffer
         */
        int update(const std::byte *data, size_t len, std::byte *out);
        /**
         * @brief Finalizes cipher, encrypting / decrypting the rest of the bytes
         *
         * Encrypts or decrypts the remaining bytes in @p out
         * and returns the written length.
         * @param out the buffer to write into
         * @return int the size written
         */
        int finalize(std::byte *out);
        /**
         * @brief Calculates minimal buffer size for the cipher
         *
         * Calculates the minimal buffer size for the cipher,
         * just for the sake of over-optimizing.
         * @param len the length of the input data
         * @return size_t the minimal size of the buffer to use
         */
        size_t calculateBufferSize(size_t len);
    };

    /**
     * @brief ZLib compressor
     *
     * Compressor class that wraps
     * around zlib for compression
     * or decompression.
     */
    class ZLibCompressor
    {
    private:
        int compressionLevel;

    public:
        /**
         * @brief Construct a new Zlib Compressor object
         *
         * Creates a compressor with a paramed zlib @p level
         * going from 0 to 9 (0 means no compression and
         * 9 means full compression). Set it to -1 to
         * use the default compression.
         * @param level the compression level
         */
        ZLibCompressor(int level);
        /**
         * @brief Destroy the Zlib Compressor object
         *
         */
        ~ZLibCompressor() = default;

        /**
         * @brief Deflates data
         *
         * Compresses @p data of length @p len and
         * writes the compressed length to @p outLen
         * returning the compressed data.
         * @param data the data to compress
         * @param len the length of @p data
         * @param outLen a pointer to an int that will contain the compressed data length
         * @return std::unique_ptr<std::byte[]> the compressed data
         */
        std::unique_ptr<std::byte[]> deflate(const std::byte *data, size_t len, int *outLen);
        /**
         * @brief Inflates data
         *
         * Uncompresses @p data of length @p len and
         * writes the uncompressed length to @p outLen
         * returning the compressed data.
         * In contrary to ::deflate @p outLen
         * should contain the uncompressed data size.
         * @param data the data to uncompress
         * @param len the length of @p data
         * @param outLen a pointer to an int that contains the uncompressed data size
         * @return std::unique_ptr<std::byte[]> the uncompressed data
         */
        std::unique_ptr<std::byte[]> inflate(const std::byte *data, size_t len, int *outLen);
    };
};

#endif